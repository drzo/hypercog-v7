import { loggerService } from '$lib/features/core/services';
import type { ImprovementAction } from '../types';
import { Octokit } from '@octokit/rest';

export class GitHubService {
  private readonly octokit: Octokit;
  private readonly owner: string;
  private readonly repo: string;

  constructor() {
    const apiKey = process.env.GIT_HUB_API_KEY;
    if (!apiKey) {
      throw new Error('GitHub API key not configured');
    }

    this.octokit = new Octokit({ auth: apiKey });
    
    const repoUrl = process.env.GIT_HUB_REPO_URL;
    if (!repoUrl) {
      throw new Error('GitHub repo URL not configured');
    }

    const match = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
    if (!match) {
      throw new Error('Invalid GitHub repo URL');
    }

    [, this.owner, this.repo] = match;
  }

  async createImprovementPR(improvement: ImprovementAction): Promise<void> {
    try {
      // Get default branch ref
      const { data: ref } = await this.octokit.git.getRef({
        owner: this.owner,
        repo: this.repo,
        ref: 'heads/main'
      });

      // Create new branch
      const branchName = `improvement/${improvement.id}`;
      await this.octokit.git.createRef({
        owner: this.owner,
        repo: this.repo,
        ref: `refs/heads/${branchName}`,
        sha: ref.object.sha
      });

      // Create commits for changes
      for (const change of improvement.changes) {
        await this.createCommit(branchName, change);
      }

      // Create pull request
      await this.octokit.pulls.create({
        owner: this.owner,
        repo: this.repo,
        title: improvement.description,
        body: this.generatePRDescription(improvement),
        head: branchName,
        base: 'main'
      });

      loggerService.info('Created improvement PR', { improvement });
    } catch (error) {
      loggerService.error('Failed to create improvement PR', error);
      throw error;
    }
  }

  private async createCommit(branch: string, change: ImprovementAction['changes'][0]): Promise<void> {
    // Get current file content if it exists
    let currentContent;
    try {
      const { data } = await this.octokit.repos.getContent({
        owner: this.owner,
        repo: this.repo,
        path: change.path,
        ref: branch
      });
      currentContent = data;
    } catch {
      // File doesn't exist yet
    }

    await this.octokit.repos.createOrUpdateFileContents({
      owner: this.owner,
      repo: this.repo,
      path: change.path,
      message: `Update ${change.path}`,
      content: Buffer.from(JSON.stringify(change.after)).toString('base64'),
      sha: currentContent?.sha,
      branch
    });
  }

  private generatePRDescription(improvement: ImprovementAction): string {
    return `
# ${improvement.description}

## Type: ${improvement.type}
## Priority: ${improvement.priority}
## Estimated Impact: ${improvement.estimatedImpact}

## Changes:
${improvement.changes.map(c => `- ${c.path}`).join('\n')}

Generated by HyperCog Self-Improvement System
    `.trim();
  }
}

export const githubService = new GitHubService();