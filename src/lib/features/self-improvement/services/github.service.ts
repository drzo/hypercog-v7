import { loggerService } from '$lib/features/core/services';
import { GitHubApiUtil } from '../utils/github-api';
import type { ImprovementAction } from '../types/improvement';

interface GitHubRef {
  ref: string;
  sha: string;
}

interface GitHubCommit {
  sha: string;
  url: string;
}

interface GitHubPR {
  number: number;
  html_url: string;
}

export class GitHubService {
  private readonly api: GitHubApiUtil;
  private readonly owner: string;
  private readonly repo: string;

  constructor() {
    const apiKey = process.env.GIT_HUB_API_KEY;
    if (!apiKey) {
      throw new Error('GitHub API key not configured');
    }

    this.api = new GitHubApiUtil(apiKey);
    
    const repoUrl = process.env.GIT_HUB_REPO_URL;
    if (!repoUrl) {
      throw new Error('GitHub repo URL not configured');
    }

    const match = repoUrl.match(/github\.com\/([^/]+)\/([^/]+)/);
    if (!match) {
      throw new Error('Invalid GitHub repo URL');
    }

    [, this.owner, this.repo] = match;
  }

  async createImprovementPR(improvement: ImprovementAction): Promise<void> {
    try {
      // Get default branch ref
      const defaultBranch = await this.getDefaultBranch();
      
      // Create new branch
      const branchName = `improvement/${improvement.id}`;
      await this.createBranch(branchName, defaultBranch.sha);

      // Create commits for changes
      for (const change of improvement.changes) {
        await this.createCommit(branchName, change);
      }

      // Create pull request
      await this.createPullRequest(branchName, improvement);

      loggerService.info('Created improvement PR', { improvement });
    } catch (error) {
      loggerService.error('Failed to create improvement PR', error);
      throw error;
    }
  }

  private async getDefaultBranch(): Promise<GitHubRef> {
    return this.api.request(`/repos/${this.owner}/${this.repo}/git/refs/heads/main`);
  }

  private async createBranch(name: string, sha: string): Promise<GitHubRef> {
    return this.api.request(`/repos/${this.owner}/${this.repo}/git/refs`, {
      method: 'POST',
      body: {
        ref: `refs/heads/${name}`,
        sha
      }
    });
  }

  private async createCommit(branch: string, change: ImprovementAction['changes'][0]): Promise<GitHubCommit> {
    // Get current file content if it exists
    const currentContent = await this.getFileContent(change.path);

    return this.api.request(`/repos/${this.owner}/${this.repo}/contents/${change.path}`, {
      method: 'PUT',
      body: {
        message: `Update ${change.path}`,
        content: Buffer.from(JSON.stringify(change.after)).toString('base64'),
        sha: currentContent?.sha,
        branch
      }
    });
  }

  private async getFileContent(path: string): Promise<{ sha: string } | null> {
    try {
      return await this.api.request(
        `/repos/${this.owner}/${this.repo}/contents/${path}`
      );
    } catch {
      return null;
    }
  }

  private async createPullRequest(branch: string, improvement: ImprovementAction): Promise<GitHubPR> {
    return this.api.request(`/repos/${this.owner}/${this.repo}/pulls`, {
      method: 'POST',
      body: {
        title: improvement.description,
        body: this.generatePRDescription(improvement),
        head: branch,
        base: 'main'
      }
    });
  }

  private generatePRDescription(improvement: ImprovementAction): string {
    return `
# ${improvement.description}

## Type: ${improvement.type}
## Priority: ${improvement.priority}
## Estimated Impact: ${improvement.estimatedImpact}

## Changes:
${improvement.changes.map(c => `- ${c.path}`).join('\n')}

Generated by HyperCog Self-Improvement System
    `.trim();
  }
}

export const githubService = new GitHubService();