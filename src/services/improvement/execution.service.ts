import { Octokit } from '@octokit/rest';
import { Logger } from '../logger.service';
import { ImprovementProposal } from './proposal.service';
import fs from 'fs/promises';
import path from 'path';

export interface ExecutionResult {
    success: boolean;
    error?: string;
    changes: {
        files: string[];
        summary: string;
    };
}

export class ExecutionService {
    private logger: Logger;
    private octokit: Octokit;
    private repoOwner: string;
    private repoName: string;

    constructor() {
        this.logger = new Logger();
        this.octokit = new Octokit({
            auth: process.env.GIT_HUB_API_KEY
        });

        // Extract owner and repo from GIT_HUB_REPO_URL
        const repoUrl = process.env.GIT_HUB_REPO_URL ?? '';
        const [, owner, name] = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/) ?? [];
        this.repoOwner = owner;
        this.repoName = name;
    }

    async executeImprovement(proposal: ImprovementProposal): Promise<ExecutionResult> {
        try {
            // Validate proposal confidence
            if (proposal.confidence < 0.7) {
                throw new Error('Proposal confidence too low for automatic execution');
            }

            // Create a new branch for the improvement
            const branchName = `improvement/${Date.now()}`;
            await this.createBranch(branchName);

            // Parse and execute the implementation steps
            const changes = await this.executeImplementation(proposal.implementation);

            // Create pull request
            await this.createPullRequest(branchName, proposal, changes);

            return {
                success: true,
                changes
            };
        } catch (error) {
            this.logger.error('Failed to execute improvement', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
                changes: {
                    files: [],
                    summary: ''
                }
            };
        }
    }

    private async createBranch(branchName: string): Promise<void> {
        // Get the default branch
        const { data: repo } = await this.octokit.repos.get({
            owner: this.repoOwner,
            repo: this.repoName
        });

        // Get the latest commit SHA
        const { data: ref } = await this.octokit.git.getRef({
            owner: this.repoOwner,
            repo: this.repoName,
            ref: `heads/${repo.default_branch}`
        });

        // Create new branch
        await this.octokit.git.createRef({
            owner: this.repoOwner,
            repo: this.repoName,
            ref: `refs/heads/${branchName}`,
            sha: ref.object.sha
        });
    }

    private async executeImplementation(implementation: string): Promise<{
        files: string[];
        summary: string;
    }> {
        // Parse implementation steps
        const steps = implementation.split('\n').filter(step => step.trim());
        const modifiedFiles: string[] = [];
        const summaryParts: string[] = [];

        for (const step of steps) {
            try {
                // Execute each step and track modifications
                const result = await this.executeStep(step);
                if (result.files.length > 0) {
                    modifiedFiles.push(...result.files);
                    summaryParts.push(result.summary);
                }
            } catch (error) {
                this.logger.error(`Failed to execute step: ${step}`, error);
                throw error;
            }
        }

        return {
            files: [...new Set(modifiedFiles)],
            summary: summaryParts.join('\n')
        };
    }

    private async executeStep(step: string): Promise<{
        files: string[];
        summary: string;
    }> {
        // TODO: Implement actual step execution logic
        // This is a placeholder that logs the step
        this.logger.info(`Executing step: ${step}`);
        return {
            files: [],
            summary: `Executed: ${step}`
        };
    }

    private async createPullRequest(
        branchName: string,
        proposal: ImprovementProposal,
        changes: { files: string[]; summary: string }
    ): Promise<void> {
        const title = `[AutoImprovement] ${proposal.description}`;
        const body = `# Automated System Improvement

## Description
${proposal.description}

## Expected Impact
${proposal.expectedImpact}

## Implementation Summary
${changes.summary}

## Modified Files
${changes.files.map(file => `- ${file}`).join('\n')}

## Confidence Score
${proposal.confidence}

---
This PR was automatically generated by HyperCog's self-improvement system.`;

        await this.octokit.pulls.create({
            owner: this.repoOwner,
            repo: this.repoName,
            title,
            body,
            head: branchName,
            base: 'main'
        });
    }
} 